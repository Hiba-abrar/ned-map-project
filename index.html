<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NED Voice Navigation</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; }
        
        .header {
            background: linear-gradient(135deg, #1e40af, #3b82f6);
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        .container { position: relative; height: calc(100vh - 80px); }
        #map { width: 100%; height: 100%; }
        
        .voice-status {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .listening {
            background: rgba(34, 197, 94, 0.9) !important;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        .backup-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 1rem;
            border-radius: 8px;
            display: none;
        }
        
        .btn {
            background: #1e40af;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin: 0.25rem;
        }
        
        .btn:hover { background: #1d4ed8; }
        
        .route-info {
            position: absolute;
            top: 100px;
            left: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            max-width: 300px;
            display: none;
        }
        
        .instructions-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            display: none;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .current-instruction {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4ade80;
            margin-bottom: 0.5rem;
        }
        
        .instruction-item {
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-left: 3px solid #6b7280;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        
        .instruction-item.active {
            border-left-color: #4ade80;
            background: rgba(74, 222, 128, 0.2);
        }
        
        .instruction-item.completed {
            opacity: 0.6;
            border-left-color: #10b981;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé§ NED Voice Navigation</h1>
        <p>Fully Voice-Controlled Campus Navigation</p>
    </div>
    
    <div class="container">
        <div id="map"></div>
        
        <div class="voice-status" id="voiceStatus">
            Click "Enable Voice" to start voice navigation...
        </div>
        
        <div class="route-info" id="routeInfo"></div>
        
        <div class="instructions-display" id="instructionsDisplay">
            <div class="current-instruction" id="currentInstruction">Ready for navigation</div>
            <div id="instructionsList"></div>
        </div>
        
        <div class="backup-controls" id="backupControls">
            <button class="btn" onclick="enableVoice()" id="enableVoiceBtn">üé§ Enable Voice</button>
            <button class="btn" onclick="isolatedSpeechTest()">üîä Isolated Speech Test</button>
            <button class="btn" onclick="directSpeechTest()">üîä Direct Speech Test</button>
            <button class="btn" onclick="startVoiceNavigation()" id="startVoiceBtn" style="display:none">üé§ Try Voice Again</button>
            <button class="btn" onclick="manualStartNav()">‚ñ∂Ô∏è Manual Start</button>
            <button class="btn" onclick="testVoice()" id="testVoiceBtn" style="display:none">üîä Test Voice</button>
            <button class="btn" onclick="toggleVoice()" id="voiceToggle" style="display:none">üîá Voice: ON</button>
            <button class="btn" onclick="forceReadAllSteps()" id="readAllBtn" style="display:none">üìú Read All Steps</button>
            <button class="btn" onclick="forceRepeatStep()" id="repeatBtn" style="display:none">üîÅ Repeat Step</button>
            <button class="btn" onclick="forceNextStep()" id="nextBtn" style="display:none">‚è≠Ô∏è Next Step</button>
            <button class="btn" onclick="stopNavigation()">‚èπÔ∏è Stop</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Configuration
        const API_BASE = 'http://localhost:8080';
        const NED_CENTER = [24.9325, 67.1139];
        
        // Global variables
        let map, locations = {}, currentRoute = null;
        let recognition = null, isListening = false, voiceEnabled = true;
        let userMarker = null, routeLayer = null, positionWatcher = null;
        let navigationState = 'idle', currentStepIndex = 0;
        let startLocation = null, endLocation = null;
        let speechQueue = [], isSpeaking = false;
        
        // Navigation states: idle, waiting_start_command, getting_start, getting_destination, navigating
        
        // Initialize system
        function initializeSystem() {
            initializeMap();
            initializeVoice();
            loadLocations();
        }
        
        // Initialize map
        function initializeMap() {
            map = L.map('map').setView(NED_CENTER, 16);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        }
        
        // Initialize voice recognition and synthesis
        function initializeVoice() {
            // Check speech synthesis support
            if (!('speechSynthesis' in window)) {
                updateVoiceStatus('Speech synthesis not supported.');
                voiceEnabled = false;
            } else {
                // Load voices
                loadVoices();
            }
            
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                updateVoiceStatus('Voice recognition not supported. Using manual controls only.');
            }
            
            // Always show backup controls
            document.getElementById('backupControls').style.display = 'block';
            
            // Don't initialize voice features until user clicks enable
            updateVoiceStatus('Click "Enable Voice" to start voice navigation');
        }
        
        // Load and initialize voices
        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            console.log('Available voices:', voices.length);
            
            if (voices.length === 0) {
                // Wait for voices to load
                speechSynthesis.addEventListener('voiceschanged', () => {
                    const newVoices = speechSynthesis.getVoices();
                    console.log('Voices loaded:', newVoices.length);
                }, { once: true });
            }
        }
        
        // Enable voice features (requires user interaction)
        function enableVoice() {
            console.log('Enabling voice features...');
            updateVoiceStatus('Enabling voice features...');
            
            // Simply enable voice and show controls
            voiceEnabled = true;
            setupVoiceRecognition();
            showVoiceControls();
            
            // Test with a simple speak call
            setTimeout(() => {
                speak('Voice enabled! Say Start Navigation to begin.');
                navigationState = 'waiting_start_command';
                setTimeout(startListening, 2000);
            }, 500);
        }
        
        // Setup voice recognition after user interaction
        function setupVoiceRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('Voice recognition not supported');
                return;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            recognition.maxAlternatives = 3;
            
            recognition.onresult = handleVoiceResult;
            recognition.onerror = handleVoiceError;
            recognition.onend = handleVoiceEnd;
            
            console.log('Voice recognition setup complete');
        }
        
        // Show voice control buttons
        function showVoiceControls() {
            document.getElementById('enableVoiceBtn').style.display = 'none';
            document.getElementById('startVoiceBtn').style.display = 'inline-block';
            document.getElementById('testVoiceBtn').style.display = 'inline-block';
            document.getElementById('voiceToggle').style.display = 'inline-block';
            document.getElementById('voiceToggle').textContent = 'üîä Voice: ON';
        }
        
        // Load all locations from backend
        async function loadLocations() {
            try {
                const response = await fetch(`${API_BASE}/locations`);
                const data = await response.json();
                
                if (data.locations) {
                    data.locations.forEach(loc => {
                        locations[loc.name.toLowerCase()] = {
                            name: loc.name,
                            coords: [loc.lat, loc.lon]
                        };
                        
                        // Add location marker
                        L.marker([loc.lat, loc.lon], {
                            icon: L.divIcon({
                                html: 'üìç',
                                iconSize: [16, 16]
                            })
                        }).addTo(map).bindPopup(loc.name);
                    });
                    
                    console.log(`Loaded ${data.locations.length} locations`);
                }
            } catch (error) {
                console.error('Failed to load locations:', error);
                speak('Failed to load campus locations. Please check server connection.');
            }
        }
        
        // Text-to-speech with queue management
        function speak(text) {
            if (!voiceEnabled) {
                updateVoiceStatus('üí¨ ' + text);
                return;
            }
            
            // Add to queue
            speechQueue.push(text);
            processNextSpeech();
        }
        
        // Process speech queue
        function processNextSpeech() {
            if (isSpeaking || speechQueue.length === 0) {
                return;
            }
            
            const text = speechQueue.shift();
            isSpeaking = true;
            
            updateVoiceStatus('üîä ' + text);
            console.log('Speaking:', text);
            
            try {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                utterance.lang = 'en-US';
                
                // Set voice if available
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    const englishVoice = voices.find(voice => voice.lang.startsWith('en') && voice.localService) || voices.find(voice => voice.lang.startsWith('en')) || voices[0];
                    if (englishVoice) {
                        utterance.voice = englishVoice;
                    }
                }
                
                utterance.onstart = () => {
                    console.log('Speech started:', text);
                };
                
                utterance.onend = () => {
                    console.log('Speech ended:', text);
                    isSpeaking = false;
                    // Process next item in queue
                    setTimeout(processNextSpeech, 100);
                };
                
                utterance.onerror = (event) => {
                    console.log('Speech error:', event.error);
                    isSpeaking = false;
                    // Process next item in queue even on error
                    setTimeout(processNextSpeech, 100);
                };
                
                speechSynthesis.speak(utterance);
                
            } catch (error) {
                console.error('Speech synthesis error:', error);
                isSpeaking = false;
                setTimeout(processNextSpeech, 100);
            }
        }
        
        // Start listening for voice input
        function startListening() {
            if (!recognition) {
                console.log('No recognition available');
                return;
            }
            
            if (isListening) {
                console.log('Already listening');
                return;
            }
            
            try {
                console.log('Starting speech recognition...');
                isListening = true;
                recognition.start();
                updateVoiceStatus('üé§ Listening...', true);
            } catch (error) {
                console.error('Failed to start listening:', error);
                isListening = false;
                // Try again after a delay
                setTimeout(() => {
                    if (!isListening && (navigationState === 'getting_start' || navigationState === 'getting_destination')) {
                        startListening();
                    }
                }, 2000);
            }
        }
        
        // Stop listening
        function stopListening() {
            if (recognition && isListening) {
                recognition.stop();
                isListening = false;
                updateVoiceStatus('Processing...');
            }
        }
        
        // Handle voice recognition results
        function handleVoiceResult(event) {
            const result = event.results[event.results.length - 1];
            const transcript = result[0].transcript.toLowerCase().trim();
            const confidence = result[0].confidence;
            
            console.log('Voice input:', transcript, 'Confidence:', confidence);
            updateVoiceStatus('Heard: "' + transcript + '"');
            
            stopListening();
            
            // Process after a short delay to show what was heard
            setTimeout(() => {
                processVoiceCommand(transcript);
            }, 1000);
        }
        
        // Process voice commands based on current state
        function processVoiceCommand(command) {
            console.log('Processing command:', command, 'State:', navigationState);
            
            switch (navigationState) {
                case 'waiting_start_command':
                    if (command.includes('start') || command.includes('begin') || command.includes('navigation') || command.includes('nav')) {
                        navigationState = 'getting_start';
                        speak("Tell me your start location, or say 'Use my GPS location'.");
                    } else {
                        speak("I heard: " + command + ". Please say 'Start Navigation' to begin.");
                        setTimeout(startListening, 2000);
                    }
                    break;
                    
                case 'getting_start':
                    handleStartLocationCommand(command);
                    break;
                    
                case 'getting_destination':
                    handleDestinationCommand(command);
                    break;
                    
                case 'calculating':
                    // Ignore voice during route calculation
                    console.log('Ignoring voice during calculation');
                    break;
                    
                case 'navigating':
                    // Handle navigation voice commands
                    handleNavigationVoiceCommand(command);
                    break;
                    
                default:
                    console.log('Ignoring voice command in state:', navigationState);
            }
        }
        
        // Handle start location voice command
        function handleStartLocationCommand(command) {
            console.log('Handling start location:', command);
            
            if (command.includes('use my gps') || command.includes('use gps') || command.includes('my location') || command.includes('current location')) {
                useCurrentLocation();
            } else {
                const location = findLocationByVoice(command);
                if (location) {
                    startLocation = location;
                    navigationState = 'getting_destination';
                    stopListening(); // Stop listening before speaking
                    speak(`Start location set to ${location.name}. Now tell me your destination.`);
                } else {
                    speak(`I heard "${command}". I didn't recognize that location. Try saying 'Main Gate' or 'Use my GPS location'.`);
                    setTimeout(startListening, 3000);
                }
            }
        }
        
        // Handle destination voice command
        function handleDestinationCommand(command) {
            console.log('Handling destination:', command);
            
            const location = findLocationByVoice(command);
            if (location) {
                endLocation = location;
                navigationState = 'calculating'; // Prevent further listening
                stopListening();
                speak(`Destination set to ${location.name}. Calculating route...`);
                calculateVoiceRoute();
            } else {
                speak(`I heard "${command}". I didn't recognize that destination. Try saying 'Library' or 'Admin Block'.`);
                setTimeout(startListening, 3000);
            }
        }
        
        // Use current GPS location as start
        function useCurrentLocation() {
            if (!navigator.geolocation) {
                speak("GPS not available. Please say a specific location.");
                setTimeout(startListening, 2000);
                return;
            }
            
            stopListening(); // Stop listening while getting GPS
            speak("Getting your current location...");
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const userLat = position.coords.latitude;
                    const userLon = position.coords.longitude;
                    
                    // Find nearest location
                    let nearest = null;
                    let minDistance = Infinity;
                    
                    Object.values(locations).forEach(loc => {
                        const distance = haversine(userLat, userLon, loc.coords[0], loc.coords[1]);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearest = loc;
                        }
                    });
                    
                    if (nearest && minDistance < 200) {
                        startLocation = nearest;
                        navigationState = 'getting_destination';
                        speak(`Using your current location near ${nearest.name}. Now tell me your destination.`);
                    } else {
                        speak("You appear to be outside the campus. Please say a specific start location.");
                        setTimeout(startListening, 2000);
                    }
                },
                (error) => {
                    speak("Could not get your location. Please say a specific start location.");
                    setTimeout(startListening, 2000);
                }
            );
        }
        
        // Find location by voice input using fuzzy matching
        function findLocationByVoice(command) {
            console.log('Finding location for command:', command);
            console.log('Available locations:', Object.keys(locations));
            
            // Fuzzy matching for common terms first
            const keywords = {
                'main gate': 'ned university main gate',
                'gate': 'ned university main gate',
                'library': 'ned university library',
                'admin': 'ned university admin block',
                'admin block': 'ned university admin block',
                'csit': 'csit labs',
                'computer': 'csit labs',
                'basketball': 'basketball court',
                'football': 'football ground',
                'cafeteria': 'dms cafeteria',
                'medical': 'ned medical centre',
                'mosque': 'mosque',
                'auditorium': 'main auditorium'
            };
            
            // Check keywords first
            for (const [keyword, locationKey] of Object.entries(keywords)) {
                if (command.includes(keyword)) {
                    const found = locations[locationKey.toLowerCase()];
                    console.log('Found by keyword:', keyword, '->', found);
                    return found;
                }
            }
            
            // Direct match
            for (const [key, location] of Object.entries(locations)) {
                if (command.includes(key.toLowerCase()) || key.toLowerCase().includes(command)) {
                    console.log('Found by direct match:', key, '->', location);
                    return location;
                }
            }
            
            console.log('No location found for:', command);
            return null;
        }
        
        // Calculate route using backend API
        async function calculateVoiceRoute() {
            console.log('Calculating route from', startLocation.name, 'to', endLocation.name);
            
            try {
                const url = `${API_BASE}/route?start=${encodeURIComponent(startLocation.name)}&end=${encodeURIComponent(endLocation.name)}`;
                console.log('API call:', url);
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('Route response:', data);
                
                if (data.error) {
                    speak('Route calculation failed. Please try different locations.');
                    resetNavigation();
                    return;
                }
                
                currentRoute = data;
                console.log('Route set, displaying...');
                
                displayRoute();
                generateTurnByTurnInstructions();
                
                const distance = Math.round(data.total_distance);
                console.log('Speaking route result, distance:', distance);
                speak(`Route calculated. Distance: ${distance} meters. Starting GPS navigation.`);
                
                setTimeout(() => {
                    console.log('Starting GPS navigation...');
                    startGPSNavigation();
                }, 2000);
                
            } catch (error) {
                console.error('Route calculation error:', error);
                speak('Failed to calculate route. Please try again.');
                resetNavigation();
            }
        }
        
        // Display route on map
        function displayRoute() {
            if (!currentRoute || !currentRoute.route) return;
            
            // Clear existing route
            if (routeLayer) map.removeLayer(routeLayer);
            
            // Create route polyline from backend coordinates
            const routeCoords = currentRoute.route.map(step => [step.lat, step.lon]);
            routeLayer = L.polyline(routeCoords, {
                color: '#1e40af',
                weight: 5,
                opacity: 0.8
            }).addTo(map);
            
            // Add start and end markers
            const startPoint = currentRoute.route[0];
            const endPoint = currentRoute.route[currentRoute.route.length - 1];
            
            L.marker([startPoint.lat, startPoint.lon], {
                icon: L.divIcon({
                    html: 'üö©',
                    iconSize: [24, 24]
                })
            }).addTo(map).bindPopup(`Start: ${startLocation.name}`);
            
            L.marker([endPoint.lat, endPoint.lon], {
                icon: L.divIcon({
                    html: 'üéØ',
                    iconSize: [24, 24]
                })
            }).addTo(map).bindPopup(`Destination: ${endLocation.name}`);
            
            // Fit map to route
            map.fitBounds(routeLayer.getBounds().pad(0.1));
        }
        
        // Generate turn-by-turn instructions from route
        function generateTurnByTurnInstructions() {
            if (!currentRoute || !currentRoute.route) return;
            
            const instructions = [];
            const route = currentRoute.route;
            
            for (let i = 0; i < route.length; i++) {
                const step = route[i];
                
                if (i === 0) {
                    instructions.push({
                        instruction: `Start from ${startLocation.name}`,
                        location: [step.lat, step.lon],
                        distance: step.distance || 0
                    });
                } else if (i === route.length - 1) {
                    instructions.push({
                        instruction: `You have arrived at ${endLocation.name}`,
                        location: [step.lat, step.lon],
                        distance: 0
                    });
                } else {
                    // Use backend instruction or generate from coordinates
                    let instruction = step.instruction || 'Continue straight';
                    
                    if (step.is_turn) {
                        instruction = `Turn ${step.direction}`;
                    } else if (step.distance > 30) {
                        instruction = `Walk straight for ${Math.round(step.distance)} meters`;
                    }
                    
                    instructions.push({
                        instruction: instruction,
                        location: [step.lat, step.lon],
                        distance: step.distance || 0
                    });
                }
            }
            
            currentRoute.instructions = instructions;
            displayWrittenInstructions();
        }
        
        // Start GPS navigation
        function startGPSNavigation() {
            if (!navigator.geolocation) {
                speak('GPS not available on this device.');
                return;
            }
            
            navigationState = 'navigating';
            currentStepIndex = 0;
            
            // Show written instructions and navigation controls
            document.getElementById('instructionsDisplay').style.display = 'block';
            document.getElementById('readAllBtn').style.display = 'inline-block';
            document.getElementById('repeatBtn').style.display = 'inline-block';
            document.getElementById('nextBtn').style.display = 'inline-block';
            updateCurrentInstruction(0);
            
            // Start GPS tracking
            positionWatcher = navigator.geolocation.watchPosition(
                updateUserPosition,
                handleGPSError,
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 2000
                }
            );
            
            // Announce first instruction
            if (currentRoute.instructions && currentRoute.instructions.length > 0) {
                speak(currentRoute.instructions[0].instruction);
            }
            
            updateVoiceStatus('üß≠ GPS Navigation Active');
        }
        
        // Update user position during navigation
        function updateUserPosition(position) {
            if (navigationState !== 'navigating') return;
            
            const userLat = position.coords.latitude;
            const userLon = position.coords.longitude;
            
            // Update user marker
            if (userMarker) map.removeLayer(userMarker);
            userMarker = L.marker([userLat, userLon], {
                icon: L.divIcon({
                    html: 'üìç',
                    iconSize: [20, 20],
                    className: 'user-marker'
                })
            }).addTo(map);
            
            // Center map on user
            map.setView([userLat, userLon], 18);
            
            // Check navigation progress
            checkNavigationProgress(userLat, userLon);
        }
        
        // Check progress and provide voice guidance
        function checkNavigationProgress(userLat, userLon) {
            if (!currentRoute.instructions || currentStepIndex >= currentRoute.instructions.length) return;
            
            const currentInstruction = currentRoute.instructions[currentStepIndex];
            const distanceToStep = haversine(userLat, userLon, currentInstruction.location[0], currentInstruction.location[1]);
            
            // Check if close to current step
            if (distanceToStep < 8) {
                if (currentStepIndex === currentRoute.instructions.length - 1) {
                    // Reached destination
                    speak('You have arrived at your destination.');
                    stopNavigation();
                    return;
                } else {
                    // Move to next step
                    currentStepIndex++;
                    const nextInstruction = currentRoute.instructions[currentStepIndex];
                    speak(nextInstruction.instruction);
                    updateCurrentInstruction(currentStepIndex);
                }
            }
            
            // Check for route deviation (less aggressive)
            let minDistanceToRoute = Infinity;
            currentRoute.route.forEach(point => {
                const distance = haversine(userLat, userLon, point.lat, point.lon);
                minDistanceToRoute = Math.min(minDistanceToRoute, distance);
            });
            
            // Only recalculate if significantly off route and not already recalculating
            if (minDistanceToRoute > 30 && navigationState === 'navigating') {
                console.log('User is off route by', minDistanceToRoute, 'meters');
                speak('You seem to be off route. Recalculating...');
                recalculateRoute(userLat, userLon);
            }
        }
        
        // Recalculate route from current position
        async function recalculateRoute(userLat, userLon) {
            console.log('Recalculating route from current position:', userLat, userLon);
            
            // Don't recalculate if we're close to the original route
            if (currentRoute && currentRoute.route) {
                let minDistanceToRoute = Infinity;
                currentRoute.route.forEach(point => {
                    const distance = haversine(userLat, userLon, point.lat, point.lon);
                    minDistanceToRoute = Math.min(minDistanceToRoute, distance);
                });
                
                // If we're back on route, don't recalculate
                if (minDistanceToRoute < 20) {
                    console.log('Back on route, not recalculating');
                    return;
                }
            }
            
            // Find nearest location to current position
            let nearest = null;
            let minDistance = Infinity;
            
            Object.values(locations).forEach(loc => {
                const distance = haversine(userLat, userLon, loc.coords[0], loc.coords[1]);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = loc;
                }
            });
            
            if (nearest && minDistance < 100) {
                console.log('Recalculating from nearest location:', nearest.name);
                const originalEnd = endLocation;
                startLocation = nearest;
                navigationState = 'calculating';
                
                try {
                    const response = await fetch(`${API_BASE}/route?start=${encodeURIComponent(nearest.name)}&end=${encodeURIComponent(originalEnd.name)}`);
                    const data = await response.json();
                    
                    if (!data.error) {
                        currentRoute = data;
                        displayRoute();
                        generateTurnByTurnInstructions();
                        currentStepIndex = 0;
                        updateCurrentInstruction(0);
                        navigationState = 'navigating';
                        speak('Route recalculated.');
                    } else {
                        speak('Could not recalculate route.');
                        navigationState = 'navigating';
                    }
                } catch (error) {
                    console.error('Recalculation failed:', error);
                    navigationState = 'navigating';
                }
            }
        }
        
        // Handle GPS errors
        function handleGPSError(error) {
            let message = 'GPS error: ';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message += 'Location access denied.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += 'Location unavailable.';
                    break;
                case error.TIMEOUT:
                    message += 'Location timeout.';
                    break;
                default:
                    message += 'Unknown error.';
            }
            speak(message);
        }
        
        // Handle voice recognition errors
        function handleVoiceError(event) {
            console.error('Voice recognition error:', event.error);
            isListening = false;
            
            if (event.error === 'no-speech') {
                updateVoiceStatus('No speech detected. Click "Try Voice Again" or speak louder.');
            } else if (event.error === 'not-allowed') {
                updateVoiceStatus('Microphone access denied. Please allow microphone access.');
            } else {
                updateVoiceStatus('Voice error: ' + event.error + '. Click "Try Voice Again".');
            }
            
            // Don't auto-restart on errors, let user manually retry
        }
        
        // Handle voice recognition end
        function handleVoiceEnd() {
            isListening = false;
            console.log('Voice recognition ended, state:', navigationState);
            
            // Only auto-restart if we're actively waiting for input
            if (navigationState === 'getting_start') {
                updateVoiceStatus('üé§ Waiting for start location...');
                setTimeout(startListening, 2000);
            } else if (navigationState === 'getting_destination') {
                updateVoiceStatus('üé§ Waiting for destination...');
                setTimeout(startListening, 2000);
            } else if (navigationState === 'waiting_start_command') {
                updateVoiceStatus('üé§ Say "Start Navigation"');
                setTimeout(startListening, 3000);
            }
        }
        
        // Update voice status display
        function updateVoiceStatus(message, listening = false) {
            const statusEl = document.getElementById('voiceStatus');
            statusEl.textContent = message;
            statusEl.className = listening ? 'voice-status listening' : 'voice-status';
        }
        
        // Display written instructions
        function displayWrittenInstructions() {
            if (!currentRoute || !currentRoute.instructions) return;
            
            const instructionsList = document.getElementById('instructionsList');
            instructionsList.innerHTML = '';
            
            currentRoute.instructions.forEach((instruction, index) => {
                const div = document.createElement('div');
                div.className = 'instruction-item';
                div.id = `instruction-${index}`;
                
                const icon = getInstructionIcon(instruction.instruction);
                div.innerHTML = `${icon} ${instruction.instruction}`;
                
                if (instruction.distance > 0) {
                    div.innerHTML += ` <span style="color: #9ca3af;">(${Math.round(instruction.distance)}m)</span>`;
                }
                
                instructionsList.appendChild(div);
            });
        }
        
        // Update current instruction display
        function updateCurrentInstruction(stepIndex) {
            if (!currentRoute || !currentRoute.instructions) return;
            
            const currentInstructionEl = document.getElementById('currentInstruction');
            const instruction = currentRoute.instructions[stepIndex];
            
            if (instruction) {
                const icon = getInstructionIcon(instruction.instruction);
                currentInstructionEl.innerHTML = `${icon} ${instruction.instruction}`;
            }
            
            // Update instruction list highlighting
            document.querySelectorAll('.instruction-item').forEach((el, index) => {
                el.classList.remove('active', 'completed');
                if (index < stepIndex) {
                    el.classList.add('completed');
                } else if (index === stepIndex) {
                    el.classList.add('active');
                }
            });
        }
        
        // Get instruction icon
        function getInstructionIcon(instruction) {
            if (instruction.includes('Start')) return 'üö©';
            if (instruction.includes('arrived')) return 'üéØ';
            if (instruction.includes('Turn left')) return '‚¨ÖÔ∏è';
            if (instruction.includes('Turn right')) return '‚û°Ô∏è';
            if (instruction.includes('straight')) return '‚¨ÜÔ∏è';
            return 'üìç';
        }
        
        // Stop navigation
        function stopNavigation() {
            navigationState = 'idle';
            currentStepIndex = 0;
            
            if (positionWatcher) {
                navigator.geolocation.clearWatch(positionWatcher);
                positionWatcher = null;
            }
            
            if (userMarker) {
                map.removeLayer(userMarker);
                userMarker = null;
            }
            
            // Hide written instructions and navigation controls
            document.getElementById('instructionsDisplay').style.display = 'none';
            document.getElementById('readAllBtn').style.display = 'none';
            document.getElementById('repeatBtn').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'none';
            
            stopListening();
            updateVoiceStatus('Navigation stopped. Say "Start Navigation" to begin again.');
            
            setTimeout(() => {
                navigationState = 'waiting_start_command';
                startListening();
            }, 3000);
        }
        
        // Reset navigation to initial state
        function resetNavigation() {
            startLocation = null;
            endLocation = null;
            currentRoute = null;
            navigationState = 'waiting_start_command';
            
            speak("Let's try again. Say 'Start Navigation' to begin.");
            setTimeout(startListening, 2000);
        }
        
        // Backup function to start voice navigation manually
        function startVoiceNavigation() {
            navigationState = 'waiting_start_command';
            speak("Say 'Start Navigation' to begin.");
            startListening();
        }
        
        // Manual navigation start (bypass voice for start command)
        function manualStartNav() {
            navigationState = 'getting_start';
            speak("Tell me your start location, or say 'Use my GPS location'.");
        }
        
        // Test voice output
        function testVoice() {
            console.log('Testing voice output...');
            const wasEnabled = voiceEnabled;
            voiceEnabled = true;
            speak('Voice test successful.');
            setTimeout(() => {
                voiceEnabled = wasEnabled;
            }, 2000);
        }
        
        // Completely isolated speech test
        function isolatedSpeechTest() {
            console.log('=== ISOLATED SPEECH TEST ===');
            
            // Stop everything
            if (recognition) {
                recognition.stop();
            }
            speechSynthesis.cancel();
            speechQueue = [];
            isSpeaking = false;
            isListening = false;
            
            updateVoiceStatus('ISOLATED TEST: Stopping all processes...');
            
            setTimeout(() => {
                console.log('Creating isolated speech...');
                const msg = new SpeechSynthesisUtterance('Testing isolated speech output');
                msg.volume = 1;
                msg.rate = 0.8;
                msg.pitch = 1;
                
                msg.onstart = function() {
                    console.log('ISOLATED SPEECH STARTED!');
                    updateVoiceStatus('üîä ISOLATED SPEECH WORKING!');
                };
                
                msg.onend = function() {
                    console.log('ISOLATED SPEECH ENDED');
                    updateVoiceStatus('Isolated speech test completed');
                };
                
                msg.onerror = function(e) {
                    console.log('ISOLATED SPEECH ERROR:', e.error);
                    updateVoiceStatus('Isolated speech error: ' + e.error);
                };
                
                console.log('Speaking isolated message...');
                speechSynthesis.speak(msg);
            }, 1000);
        }
        
        // Direct speech test - bypass queue for testing
        function directSpeechTest() {
            console.log('Direct speech test starting...');
            updateVoiceStatus('Testing direct speech...');
            
            // Clear any existing speech
            speechSynthesis.cancel();
            speechQueue = [];
            isSpeaking = false;
            
            setTimeout(() => {
                const msg = new SpeechSynthesisUtterance('Hello, this is a direct speech test');
                msg.volume = 1;
                msg.rate = 1;
                msg.pitch = 1;
                
                const voices = speechSynthesis.getVoices();
                console.log('Available voices:', voices.length);
                if (voices.length > 0) {
                    const goodVoice = voices.find(v => v.lang.includes('en') && v.localService) || voices[0];
                    msg.voice = goodVoice;
                    console.log('Using voice:', goodVoice.name, goodVoice.lang);
                }
                
                msg.onstart = function() {
                    console.log('Direct speech started!');
                    updateVoiceStatus('Direct speech working!');
                };
                
                msg.onend = function() {
                    console.log('Direct speech ended');
                };
                
                msg.onerror = function(e) {
                    console.log('Direct speech error:', e.error);
                    updateVoiceStatus('Direct speech error: ' + e.error);
                };
                
                console.log('System speech synthesis speaking:', speechSynthesis.speaking);
                console.log('System speech synthesis pending:', speechSynthesis.pending);
                console.log('System speech synthesis paused:', speechSynthesis.paused);
                
                speechSynthesis.speak(msg);
            }, 200);
        }
        
        // Toggle voice on/off
        function toggleVoice() {
            voiceEnabled = !voiceEnabled;
            const toggleBtn = document.getElementById('voiceToggle');
            toggleBtn.textContent = voiceEnabled ? 'üîä Voice: ON' : 'üîá Voice: OFF';
            
            if (voiceEnabled) {
                speak('Voice output enabled.');
            } else {
                updateVoiceStatus('Voice output disabled.');
                speechSynthesis.cancel();
            }
        }
        
        // Test function for Main Gate
        function testMainGate() {
            console.log('Testing Main Gate selection');
            navigationState = 'getting_start';
            handleStartLocationCommand('main gate');
        }
        
        // Handle voice commands during navigation
        function handleNavigationVoiceCommand(command) {
            console.log('Navigation voice command:', command);
            
            if (command.includes('read all') || command.includes('all steps') || command.includes('full route')) {
                readAllSteps();
            } else if (command.includes('repeat') || command.includes('again') || command.includes('current')) {
                repeatStep();
            } else if (command.includes('next') || command.includes('skip')) {
                nextStep();
            } else if (command.includes('where am i') || command.includes('current location')) {
                announceCurrentLocation();
            } else if (command.includes('how far') || command.includes('distance')) {
                announceRemainingDistance();
            }
        }
        
        // Read all navigation steps
        function readAllSteps() {
            if (!currentRoute || !currentRoute.instructions) {
                speak('No route available.');
                return;
            }
            
            console.log('Reading all steps:', currentRoute.instructions);
            stopListening(); // Stop listening during long speech
            
            let allSteps = 'Here is your complete route: ';
            currentRoute.instructions.forEach((instruction, index) => {
                allSteps += `Step ${index + 1}: ${instruction.instruction}. `;
                if (instruction.distance > 0) {
                    allSteps += `Distance: ${Math.round(instruction.distance)} meters. `;
                }
            });
            
            console.log('Speaking all steps:', allSteps);
            speak(allSteps);
            
            // Resume listening after speech
            setTimeout(() => {
                if (navigationState === 'navigating') {
                    console.log('Resuming listening after reading all steps');
                    startListening();
                }
            }, Math.max(allSteps.length * 80, 5000)); // Longer estimate for speech time
        }
        
        // Repeat current step
        function repeatStep() {
            if (!currentRoute || !currentRoute.instructions || currentStepIndex >= currentRoute.instructions.length) {
                speak('No current step available.');
                return;
            }
            
            const currentInstruction = currentRoute.instructions[currentStepIndex];
            speak(`Current step: ${currentInstruction.instruction}`);
        }
        
        // Move to next step manually
        function nextStep() {
            if (!currentRoute || !currentRoute.instructions) {
                speak('No route available.');
                return;
            }
            
            if (currentStepIndex >= currentRoute.instructions.length - 1) {
                speak('You are already at the final step.');
                return;
            }
            
            currentStepIndex++;
            const nextInstruction = currentRoute.instructions[currentStepIndex];
            speak(`Next step: ${nextInstruction.instruction}`);
            updateCurrentInstruction(currentStepIndex);
        }
        
        // Announce current location
        function announceCurrentLocation() {
            if (currentStepIndex < currentRoute.instructions.length) {
                const current = currentRoute.instructions[currentStepIndex];
                speak(`You are currently on step ${currentStepIndex + 1}: ${current.instruction}`);
            } else {
                speak('Navigation complete.');
            }
        }
        
        // Announce remaining distance
        function announceRemainingDistance() {
            if (!currentRoute || !currentRoute.instructions) {
                speak('No route available.');
                return;
            }
            
            let remainingDistance = 0;
            for (let i = currentStepIndex; i < currentRoute.instructions.length; i++) {
                remainingDistance += currentRoute.instructions[i].distance || 0;
            }
            
            const stepsRemaining = currentRoute.instructions.length - currentStepIndex - 1;
            speak(`Remaining distance: ${Math.round(remainingDistance)} meters. ${stepsRemaining} steps remaining.`);
        }
        
        // Force functions that work regardless of navigation state
        function forceReadAllSteps() {
            console.log('Force reading all steps');
            readAllSteps();
        }
        
        function forceRepeatStep() {
            console.log('Force repeat step');
            repeatStep();
        }
        
        function forceNextStep() {
            console.log('Force next step');
            nextStep();
        }
        
        // Utility: Calculate distance between two points
        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }
        
        // Initialize system when page loads
        window.addEventListener('load', initializeSystem);
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (positionWatcher) {
                navigator.geolocation.clearWatch(positionWatcher);
            }
            if (recognition) {
                recognition.stop();
            }
        });
    </script>
</body>
</html>